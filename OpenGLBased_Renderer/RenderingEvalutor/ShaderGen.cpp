/*
 * 2014 Cui.YY
 * cuiyingyun@gmail.com
 */


#include <ShaderGen.h>
namespace android
{

//Shader for vertex
const char * ShaderGen::gVS_Header_Attribute_vertexPosition =
    "attribute vec4 a_vertexPosition;\n";
const char * ShaderGen::gVS_Header_Uniform_rotationMatrix =
    "uniform mat4 u_rotationMatrix;\n";
const char * ShaderGen::gVS_Header_Uniform_scaleMatrix =
    "uniform mat4 u_scaleMatrix;\n";
const char * ShaderGen::gVS_Header_Uniform_translationMatrix =
    "uniform mat4 u_translationMatrix;\n";
const char * ShaderGen::gVS_Header_Uniform_OrthoProjcMatrix =
    "uniform mat4 u_orthoProjecMatrix;\n";
const char * ShaderGen::gVS_Header_Attribute_passColor =
    "attribute vec4 a_passColor;\n";
const char *ShaderGen::gVS_Header_Attribute_texCoord =
    "attribute vec2 a_texCoord;\n";
const char * ShaderGen::gVS_Header_Varying_colorToFrag =
    "varying vec4 v_colorToFrag;\n";
const char * ShaderGen::gVS_Header_Varying_texCoordToFrag =
    "varying vec2 v_tcToFrag;\n";

const char * ShaderGen::gVS_Main_Start_Function =
    "void main() {\n";

const char * ShaderGen::gVS_Function_Direct_Pass_Position =
    "   gl_Position = a_vertexPosition;\n";
const char * ShaderGen::gVS_Function_Pass_RO_Multi_Position =
    "   gl_Position = u_rotationMatrix * gl_Position;\n";
const char * ShaderGen::gVS_Function_Pass_SC_Multi_Position =
    "   gl_Position = u_scaleMatrix * gl_Position;\n";
const char * ShaderGen::gVS_Function_Pass_TR_Multi_Position =
    "   gl_Position = u_translationMatrix * gl_Position;\n";
const char * ShaderGen::gVS_Function_OrthoProjection_Multi_Position =
    "   gl_Position = u_orthoProjecMatrix * gl_Position;\n";
const char * ShaderGen::gVS_Function_Pass_Color_To_Frag =
    "   v_colorToFrag = a_passColor;\n";
const char * ShaderGen::gVS_Function_Pass_texCoord_To_Frag =
    "   v_tcToFrag = a_texCoord;\n";

/* WikiPedia
A Gaussian blur effect is typically generated by convolving an image with a kernel
of Gaussian values. In practice, it is best to take advantage of the Gaussian Blur's
linearly separable property by dividing the process into two passes. In the first pass,
a one-dimensional kernel is used to blur the image in only the horizontal or vertical
direction. In the second pass, another one-dimensional kernel is used to blur in the
remaining direction. The resulting effect is the same as convolving with a two-dimensional
kernel in a single pass, but requires fewer calculations.
*/
const char * ShaderGen::gVS_Function_Gaussian_Blur =
    "";

const char * ShaderGen::gVS_Main_End_Function =
    "}\n";

//Shader for fragment
const char * ShaderGen::gFS_Header_Precision_Mediump_Float =
    "precision mediump float;\n";
const char * ShaderGen::gFS_Header_Varying_colorToFrag =
    "varying vec4 v_colorToFrag;\n";
const char * ShaderGen::gFS_Header_Varying_texCoordToFrag =
    "varying vec2 v_tcToFrag;\n";
const char * ShaderGen::gFS_Header_Sampler2D =
    "uniform sampler2D u_samplerTexture;\n";
const char * ShaderGen::gFS_Header_Brightness_Alpha =
    "uniform float u_brightnessAlpha;\n";

const char * ShaderGen::gFS_Main_Start_Function =
    "void main() {\n";

const char * ShaderGen::gFS_Function_Pass_Constant_Color =
    "  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n";
const char * ShaderGen::gFS_Function_Direct_Pass_Color =
    "  gl_FragColor = v_colorToFrag;\n";
const char * ShaderGen::gFS_Function_Direct_Sampler_texCoord =
    "  vec4 textureColor = texture2D( u_samplerTexture, v_tcToFrag );\n\
  gl_FragColor = vec4(textureColor.rgb * exp2(1.2f), textureColor.w);\n";
const char * ShaderGen::gFS_Function_Brightness =
    "  gl_FragColor = gl_FragColor * u_brightnessAlpha;\n";
const char * ShaderGen::gFS_Function_Grayscale =
    "  vec3 lumCoeff = vec3(0.2125, 0.7154, 0.0721); \n \
 float lum = dot(lumCoeff, gl_FragColor.rgb); \n \
 gl_FragColor = vec4(lum, lum, lum, 1.0);";

const char * ShaderGen::gFS_Function_Gaussian_Blur =
    "";
const char * ShaderGen::gFS_Main_End_Function =
    "}\n";

}
